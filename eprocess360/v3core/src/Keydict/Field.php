<?php
/**
 * Created by PhpStorm.
 * User: kira
 * Date: 8/13/2015
 * Time: 11:11 AM
 */

namespace eprocess360\v3core\Keydict;


use eprocess360\v3core\DB;
use eprocess360\v3core\Keydict;
use eprocess360\v3core\Keydict\StorageStrategy\InterfaceStorageStrategy;
use eprocess360\v3core\Model;
use eprocess360\v3core\Request\Request;

/**
 * Class Field
 * A general Keydict/Entry class that holds the functions shared between them.  The Exception functions required for
 * handling exceptions thrown by the Form, Keydict and Entry.
 * @package eprocess360\v3core\Keydict
 */
abstract class Field
{
    /** This is delimiter used by the getName() method for building parent/child relationship aware names. */
    const DELIMITER = '';
    /** This is the TYPE of this Field */
    const TYPE = self::TYPE_ENTRY;

    /** These are static types - never change these only add new and update TYPE_ANY */
    const TYPE_KEYDICT = 1;
    const TYPE_ENTRY = 2;
    const TYPE_CONTAINER = 4;
    const TYPE_COMPOSITE = 6;
    const TYPE_FLAGS = 8;
    const TYPE_FLAG = 16;
    const TYPE_ANY = 31;
    const MUST_VALIDATE = 32;

    /** @var \Exception[] */
    protected $exceptions;
    /** @var bool */
    protected $accepted_post;
    /** @var InterfaceStorageStrategy */
    protected $storage_strategy;
    /** @var string */
    protected $label;
    /** @var array */
    protected $meta = [];
    /** @var null|string  */
    protected $name = null;
    /** @var Field The parent object */
    protected $parent;
    /** @var Field[] Fields directly controlled by the object - Indexes are built as needed */
    protected $fields = [];
    /** @var bool */
    protected $composite_container = false;
    /** @var bool */
    protected $saved = false;
    /** @var mixed */
    protected $value;
    /** @var \Closure[] */
    protected $lateValidators = [];
    /** @var array */
    protected $specification;
    protected $joins = [];
    protected $joinSummary;
    protected $default = null;

    /**
     * @param $key
     * @return Field|Entry|Keydict
     * @throws \Exception
     */
    public function __get($key)
    {
        if (!$this->__isset($key)) {
            throw new \Exception("Field with key '{$key}' in '{$this->getName(-1)}' does not exist.");
        }
        return $this->fields[$key];
    }


    public function defaults()
    {
        if (method_exists($this,'idContainer') && $this->isContainer()) {
            foreach ($this->allFields(self::TYPE_ENTRY, true) as $entry) {
                $entry->defaults();
            }
        } else {
            $this->value = $this->default;
        }
        return $this;
    }

    /**
     * @param $key
     * @return bool
     */
    public function __isset($key)
    {
        return isset($this->fields[$key]);
    }

    /**
     * @param $key
     * @return Field|Keydict|Entry
     * @throws \Exception
     */
    public function getField($key)
    {
        return $this->__get($key);
    }

    /**
     * @param $key
     * @return bool|Keydict|Composite
     */
    public function findField($key)
    {
        if ($this->__isset($key)) {
            return $this->$key;
        }
        foreach ($this->allFields(self::TYPE_CONTAINER) as $container) {

            //echo "findField {$key} from {$container->getName(-1)}\r\n";
            if ($container->__isset($key)) {
                return $container->$key;
            } else {
                if ($result=$container->findField($key)) {
                    return $result;
                }
            }
        }
        return false;
    }

    /**
     * Add a Field
     * @param Field $field
     * @param bool $addParent
     * @return $this
     */
    public function add(Field $field, $addParent = true)
    {
        if ($addParent) {
            $field->setParent($this);
        }
        $this->fields[$field->getRawName()] = $field;
        return $this;
    }


    /**
     * Add an Exception to the Form's Exception list
     * @param \Exception $exception
     */
    public function addException(\Exception $exception)
    {
        $this->exceptions[] = $exception;
        if ($this->hasParent()) {
            $this->getParent()->addException($exception);
        }
    }

    /**
     * Check to see if the Form has Exceptions after acceptPost()
     * @return bool
     * @throws \Exception
     */
    public function hasException()
    {
        return (bool)sizeof($this->exceptions);
    }

    /**
     * Get the Exceptions generated by acceptPost()
     * @return \Exception[]
     * @throws \Exception
     */
    public function getException()
    {
//        if (!$this->accepted_post) {
//            throw new \Exception("The Form has not accepted the POST parameters yet and cannot call getExceptions().");
//        }
        return $this->exceptions;
    }

    /**
     * @param string|null $name
     * @return Field
     * @throws Exception\KeydictException
     */
    public function setName($name)
    {
        if (!ctype_alnum($name)) {
            throw new Keydict\Exception\KeydictException("Field name '{$name}' must be alphanumeric.");
        } elseif (ctype_digit(substr($name,0,1))) {
            throw new Keydict\Exception\KeydictException("Field name '{$name}' must not start with a number.");
        }
        if ($name == 'name') {
            throw new Keydict\Exception\KeydictException('Field name cannot be named \'name\'.');
        }
        $this->name = $name;
        return $this;
    }

    /**
     * @return InterfaceStorageStrategy
     */
    public function getStorageStrategy()
    {
        return $this->storage_strategy;
    }

    /**
     * @param InterfaceStorageStrategy $storage_strategy
     * @return Field
     */
    public function setStorageStrategy(InterfaceStorageStrategy $storage_strategy)
    {
        $this->storage_strategy = $storage_strategy;
        return $this;
    }

    /**
     * @return string
     */
    public function getLabel()
    {
        return $this->label;
    }

    /**
     * @param string $label
     * @return $this
     */
    public function setLabel($label)
    {
        $this->label = $label;
        return $this;
    }

    /**
     * Set a meta key/value pair on the Entry.  This is part of the runtime configuration.  Value is optional.
     * @param $key
     * @param null $value
     * @return $this
     */
    public function setMeta($key, $value = null)
    {
        $this->meta[$key] = $value;
        return $this;
    }

    /**
     * @param ...$items
     * @return Field|Entry
     */
    public function setMetaArray($items)
    {
        foreach ($items as $key=>$value) {
            $this->setMeta($key, $value);
        }
        return $this;
    }

    /**
     * Check to see if the Keydict meta has a particular meta key.
     * @param $key
     * @param bool|false $inverse
     * @return bool
     */
    public function hasMeta($key, $inverse = false)
    {
        return array_key_exists($key, $this->meta) ? !$inverse : $inverse;
    }

    /**
     * Unset a particular meta key/value on the Keydict by specifying the key
     * @param $key
     * @return $this
     */
    public function unsetMeta($key)
    {
        unset($this->meta[$key]);
        return $this;
    }

    /**
     * Get a particular meta key value from the Keydict, or throw an Exception is the key does not exist.
     * @param $key
     * @return mixed
     * @throws \Exception
     */
    public function getMeta($key)
    {
        if ($this->hasMeta($key)) {
            return $this->meta[$key];
        }
        throw new \Exception("Meta key {$key} does not exist.");
    }

    /**
     * @return bool
     */
    public function hasParent()
    {
        return is_object($this->parent);
    }

    /**
     * @return Field
     */
    public function getParent()
    {
        return $this->parent;
    }

    /**
     * @param $parent
     * @return InterfaceField
     */
    public function setParent($parent)
    {
        $this->parent = $parent;
        return $this;
    }

    /**
     * @param int $depth
     * @return string
     */
    public function getName($depth = 0)
    {

        $delimiter = '';
        if ($this->getParent() == null && $this->name == null) {
            return '';
        }
        if (!$this->composite_container) {
            $delimiter = static::DELIMITER;
        }

        if ($this->name=='children') return ($this->getParent() && $depth ? $this->getParent()->getName($depth - 1) : '');
        return ($this->getParent() && $depth ? $this->getParent()->getName($depth - 1) : '') . ($this->name ? $delimiter . $this->name . static::DELIMITER : '');
    }

    public function getPath($path=[], $trim = 0)
    {
        if ($this->getRawName()) {
            $path[] = $this->getRawName();
        }
        $parent = $this->getParent();
        if ($parent !== null) {
            return $this->getParent()->getPath($path, $trim);
        }
        while ($trim) {
            --$trim;
            array_pop($path);
        }
        return $path;
    }

    /**
     * Indicates that this Entry has a relationship with another table.  The corresponding table must have an Entry with
     * the exact same name.
     * @param Model $table
     * @param null $columnName
     * @return Field
     * @throws \Exception
     */
    public function joinsOn(Model $table, $columnName = null)
    {
        /** todo this is wrong but not required right now */
        $this->joins[$columnName ? : 0] = $table;
        return $this;
    }

    public function eventAddedToParent()
    {
        if ($this->getParent()->getClass() == 'Table' && sizeof($this->joins)) {
            foreach ($this->joins as $table) {
                $this->getParent()->addJoin($this, $table);
            }
        }
    }

    /**
     * Marks a field as should be indexed
     * @return Field
     */
    public function index()
    {
        return $this;
    }

    /**
     * Allows a table to be aware of where it's children can join to
     * @param Field $field
     * @param Model $table
     */
    public function addJoin(Field $field, Model $table)
    {
        $this->joinSummary[$table->getRawName()] = $field;
    }

    /**
     * @param string $table
     * @return Field
     */
    public function lookupFieldForTableJoin($table)
    {
        return $this->joinSummary[$table];
    }

    /**
     * this is an experimental name getter
     * @return string
     * @throws \Exception
     */
    public function getColumnName()
    {
        if ($this->getParent()->getClass() == 'Table') return '`'.$this->getParent()->getName().'`.`'.$this->name.'`';
        throw new \Exception("Cannot getTableName for '{$this->name}' for an object that is not a direct descendant of Table.  Currently '{$this->getParent()->getClass()}'.");
    }

    /**
     * This returns the name of the Field sans any parent/child relationship formatting
     * @return string|null
     */
    public function getRawName()
    {
        return $this->name;
    }

    /**
     * Returns the first or many fields that match a Field::TYPE filter.
     * @param $type
     * @param bool|true $first
     * @return Field|Field[]|null
     */
    public function getFieldByType($type, $first = true)
    {
        foreach ($this->getFields() as $key => $field) {
            if ($type & $field::TYPE) {
                if ($first) {
                    return $field;
                }

            }
        }
        return null;
    }

    /**
     * Returns the first or many fields that match a getClass filter.
     * @param $class
     * @param bool|true $first
     * @return Field|Field[]|null
     * @return Field|Field[]|null
     */
    public function getFieldByClass($class, $first = true)
    {
        /**
         * @var String $key
         * @var Field $field
         */
        foreach ($this->getFields() as $key => $field) {
            if ($class == $field->getClass()) {
                if ($first) {
                    return $field;
                }
            }
        }
        return null;
    }

    /**
     * Get all the Fields (Entries/Keydicts) directly managed by this Field, or optionally recursively all Fields
     * @param int $type
     * @param bool $local_only Only get Fields from this object
     * @return Field[]|Entry[]|Keydict[]
     * @throws \Exception
     */
    public function allFields($type = self::TYPE_ANY, $local_only = false)
    {
        if (!$this->isContainer()) {
            throw new \Exception("No fields on a non-container");
        }
        foreach ($this->getFields() as $key=>$field) {
            if (!$local_only && $type & static::TYPE_COMPOSITE && $field->isContainer() && $field instanceof Entry) {
                foreach ($field->allFields($type) as $composite_field) {
                    yield $composite_field;
                }
            } elseif (!$local_only && $type & static::TYPE_KEYDICT && $field->isContainer() && $field instanceof Keydict) {
                foreach ($field->allFields($type) as $keydict_field) {
                    yield $keydict_field;
                }
            } else {
                if ($type & static::TYPE_KEYDICT && $field instanceof Keydict) {
                    yield $field;
                } elseif ($type & static::TYPE_ENTRY && $field instanceof Entry) {
                    yield $field;
                } elseif ($type & static::TYPE_COMPOSITE && $field instanceof Entry && $field->isContainer()) {
                    yield $field;
                } elseif ($type & static::TYPE_CONTAINER && $field->isContainer()) {
                    yield $field;
                }
            }
        }
    }


    /**
     * Returns the Field::TYPE for the Field.
     * @return int
     */
    public function getType()
    {
        return $this::TYPE;
    }

    /**
     * Returns all Fields for this Field.
     * @return Field[]
     */
    public function getFields()
    {
        return $this->fields;
    }

    /**
     * Using the automatic naming conventions, allow this Entry to detect the POST parameter and set itself.  This
     * function should be encapsulated in a try/catch because data validation errors will throw Exceptions
     * @throws \Exception
     */
    public function acceptPost()
    {
        if ($this->isContainer()) {
            foreach ($this->allFields() as $field) {
                $field->acceptPost();
                $field->tryLateValidators();
            }
            $this->tryLateValidators();
        } elseif ($this instanceof Entry) {
            try {
                if (array_key_exists($this->getFormName(), $_POST)) {
                    $value = $_POST[$this->getFormName()];
                    $this->set($value);
                    $this->tryLateValidators();
                }
            } catch (Keydict\Exception\InvalidValueException $exception) {
                $this->addException($exception);
            } catch (\Exception $exception) {
                $this->addException($exception);
            }
        }
        return $this;
    }

    public function acceptJson($depth = 0, $trim = 0)
    {
        if ($this->isContainer()) {
            if ($depth===0 && $this->getRawName()) {
                $trim = 1;
            }
            foreach ($this->allFields() as $field) {
                $field->acceptJson($depth++, $trim);
                $field->tryLateValidators();
            }
            $this->tryLateValidators();
        } elseif ($this instanceof Entry) {
            global $phpInput;
            if (!isset($phpInput)) {
                $phpInput = Request::get()->getRequestBody();
                if (!$phpInput) {
                    throw new \Exception("Cannot accept non-JSON input.");
                } elseif (!sizeof($phpInput)) {
                    throw new \Exception("Input JSON is empty.");
                }
            }
            try {
                $path = $this->getPath([], $trim);
                $data = $phpInput;
                while (sizeof($path)) {
                    $item = array_pop($path);
                    if (isset($data[$item])) {
                        $data = $data[$item];
                        if (sizeof($path)===0) {
                            $this->set($data);
                            $this->tryLateValidators();
                        }
                    } else {
                        break;
                    }
                }
            } catch (Keydict\Exception\InvalidValueException $exception) {
                $this->addException($exception);
            }
        }
        return $this;
    }

    /**
     * Run the Late Validators attached to this specific object.  The Validator will be given access to $this only.  If
     * you need a validator with more scope, consider attaching it to a higher member of the Keydict.
     */
    public function tryLateValidators()
    {
        if (!is_array($this->lateValidators)) {
            throw new Keydict\Exception\KeydictException("LateValidators must be stored as an array in the Field.");
        }
        foreach ($this->lateValidators as $lateValidator) {
            $lateValidator($this);
        }
    }

    /**
     * Whether or not the Field is a container
     * @return bool
     */
    public function isContainer()
    {
        return static::TYPE & Field::TYPE_CONTAINER;
    }

    /**
     * Returns a complete array of the object's parents as Fields
     * @param array $child_parents
     * @return Field[]
     */
    public function getParents($child_parents = [])
    {
        array_push($child_parents, $this);
        if ($this->hasParent()) {
            return $this->getParent()->getParents($child_parents);
        }
        return $child_parents;
    }

    /**
     * Sleep the value of the Field and prepare it for saving into the database.  This function should never cleanse.
     * @param int $depth
     * @return string
     */
    public function sleep($depth = 0)
    {
        return "{$depth}";
    }

    /**
     * Basic cleanse handler
     * @return string
     */
    public function getCleanValue()
    {
        return DB::cleanse($this->value);
    }

    /**
     * Wakes up serialized? information from the database.  Each Field may require a different mode of serialization.
     * @param $raw
     * @return Field
     */
    public function wakeup($raw)
    {
        $this->value = $raw;
        return $this;
    }

    /**
     * Get the current value of the object.  This is the raw value and not necessarily the one stored in the database.
     * @return mixed
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * Returns the Specification of the Field or Fields.  Needs to be refactored to differentiate between the two.
     * @param int $depth
     * @return array
     */
    public function getSpecification($depth = 0)
    {
        return ['depth'=>$depth];
    }

    /**
     * @return boolean
     */
    public function isSaved()
    {
        return $this->saved;
    }

    /**
     * Helpful for debugging very complex Keydicts.  Try var_dump() on the output.
     * @return array
     * @throws \Exception
     */
    public function visualize()
    {
        $out = [];
        /** @var Entry $field */
        foreach ($this->allFields(self::TYPE_ANY, true) as $field) {
            if ($field->isContainer())
                $out[$field->getName()] = $field->visualize();
            else
                $out[$field->getName()] = $field->getClass().':'.($field->hasMeta('title')?$field->getMeta('title'):$field->getName()).': '.$field->get()===false?(bool)$field->get():is_array($field->get())?implode('; ',$field->get()):$field->get();
        }
        return $out;
    }

    /**
     * Array form of a Table. Quite literally the exact same as visualize() function.
     * @return array
     * @throws \Exception
     */
    public function toArray()
    {
        $out = [];
        /** @var Entry $field */
        foreach ($this->allFields(self::TYPE_ANY, true) as $field) {
            if ($field->isContainer())
                $out[$field->getName()] = $field->visualize();
            else
                $out[$field->getName()] = $field->sleep();
        }
        return $out;
    }

    /**
     * @param boolean $saved
     * @return Field
     */
    public function setSaved($saved)
    {
        $this->saved = $saved;
        return $this;
    }

    /**
     * This checks to see if the primary_key type exists in the local specification.  Should only be used with Entry and
     * not Keydict.
     * @return bool
     */
    public function isPrimaryKey()
    {
        return array_key_exists('primary_key', $this->getSpecification()) && $this->getSpecification()['primary_key'];
    }

    /**
     * This checks a meta to see if the key has a remote primary key
     * @return bool
     */
    public function isForeignPrimaryKey()
    {
        return $this->hasMeta('foreignPrimaryKey');
    }

    /**
     * Set if Field is a Composite Container.
     * @throws \Exception
     */
    public function setIsCompositeContainer()
    {
        throw new \Exception("Cannot call setIsCompositeContainer on Field base class.");
    }

    /**
     * Override the specification of the Field
     * @param $array
     */
    protected function setSpecification($array)
    {
        $this->specification = $array;
    }

    /**
     * Returns the name of the class without the namespace.
     * @return string
     */
    public function getClass()
    {
        $class = get_called_class();
        return substr($class, strrpos($class,'\\')+1);
    }

    /**
     * Add a Late Validator.
     * @param $key
     * @param \Closure $validatorFunction
     * @return $this
     */
    public function addLateValidator($key, \Closure $validatorFunction)
    {
        $this->lateValidators[$key] = $validatorFunction;
        return $this;
    }

    /**
     * @param $key
     * @return \Closure
     * @throws \Exception
     */
    public function getLateValidator($key)
    {
        if ($this->hasLateValidator($key)) {
            return $this->lateValidators[$key];
        }
        throw new \Exception("Late Validator '{$key}' not found.");
    }

    /**
     * Remove a Late Validator
     * @param $key
     * @return $this
     * @throws \Exception
     */
    public function removeLateValidator($key)
    {
        if ($this->hasLateValidator($key)) {
            unset($this->lateValidators[$key]);
            return $this;
        }
        throw new \Exception("Failed to remove Late Validator '{$key}'.");
    }

    /**
     * Whether or not the Field has the given Late Validator
     * @param $key
     * @return bool
     */
    public function hasLateValidator($key)
    {
        return array_key_exists($key, $this->lateValidators);
    }

    /**
     * @return mixed
     */
    public function getJoinSummary()
    {
        return $this->joinSummary;
    }

    /**
     * @param mixed $joins
     * @return Field
     */
    public function setJoins($joins)
    {
        $this->joins = $joins;
        return $this;
    }

    /**
     * @return mixed
     */
    public function getJoins()
    {
        return $this->joins;
    }
}