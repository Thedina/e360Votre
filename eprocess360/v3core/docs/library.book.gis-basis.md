*** Implementation and Usage Notes

Just some ramblings from a mad frog.

Library Controller
Book Controller

Definitely on to something.

```
// adding the Library to the Project
$this->addController(Library::build('library', $this)->setDescription('Library'));

// the library can have multiple local and foreign keydicts, which are stored as Book
// Local books are 'create'ed, and the owner of the book is to the local controller
// Foreign books are 'borrow'ed, and the owner of the book remains externally
$library->addBooks(
    Book::create(
        // the title of the Book
        'local',
        // followed by the contents
        IdInteger::build('idProject', 'Project ID'),
        Integer::build('favoriteFood', 'Favorite Food')
    ),
    Foods::borrow(),
    SmartyStreets::borrow('smartystreets') // the title is optional
);
// Library::addBooks() will index the Books given.  It will add some identifying information into them so addressing
// works properly.

// Books are not 'opened' unless they are read.  That is to say there are no underlying SQL calls unless
// data is specifically needed.  The first time data is needed from a Book, a record will be created.  For local Books,
// the record is authoritative and lives in the local data table.  For foreign Books, the record is a change log that is
// joined with the freshest base possible.  At the receiving end of the api however, it doesn't know that any particular
// magic has even happened.  So that changes can be identified later on per-project granularity, the change log will 
// only store NULL values for unchanged data.  The NULL values will be merged with data from the assigned base.  Foreign
// books will typically not save directly back anywhere, plus it'd be rude to write in something you borrowed.

//  SmartyStreets
//  idRecord    basis   idController    idObject    address     colA    colB
//  0                                               123 A St    Apples  Banana          2014
//  1                                               123 A St    Apples  Banada          2015
//  2           0       2048            523         NULL        Oranges Banada
//  3           1       2048            524

// res                                              123 A St    Oranges Banada

//  Fixtures AUTH
//  idRecord    basis   idController    idObject    address     sinks   bathtubs
//  0                                               123 A St    2       1
//  1                                               123 A St    2       3
//  2           1       2048            523         NULL        2       2

// res                                              123 A St    Oranges Banada

// at some point the admin configuration will be loaded and the favoriteFood will be given a foreign key
$library->local->favoriteFood->setForeignKey($library->Foods->name);

// now the favoriteFood Entry has a foreignKey, and any input in the Entry will need to validate against the external
// resource.  Once it has validated, it won't need to revalidate again unless it is strcmp() changed.

// after validation, the project can utilize the foreign resources
$ingrediants = $library->Foods->ingrediants;
// you can also temporarily use a resource via different ID
$leastFavoriteFood = $library->Foods->lookup('Partially Hydrogenated Vegetable Oil');
// and even save over the reference
$leastFavoriteFood->ingrediants->set('Plastic')->save();
// the references will of course only be stored in the context of the current idController + idObject (the project)
// it will be accessible in the future to the current project and also database administrators or data curators with
// too much free time
```

*** Technicals: Local and Foreign Keydicts

Foreign keydicts represent data that is not necessarily generated by e360 that should be available for more than one 
project based on identifying information.  Projects can be linked by their correlation to a foreign keydict.  A full
history of local changes to the data is kept to enable transparency but also give the client the ability to write-back
to the source system.

The most common kinds of foreign keydicts expected are those for ESRI GIS and a tool might be required to setup the 
keydict model for each client.

- Local keydicts stored in a designated table.  The keydict model is defined by the Controller implementing Variables
- Foreign keydicts stored in App\ForeignModel and (preset\ForeignModel ?).  The models should define what data will be
accepted from the external resource and saved into the database.
- Foreign keydicts need to be identified using a local Keydict Entry (essentially $foreignModel->identifyBy($entry))
- Foreign keydicts can save(), but they save in the context of the parent idController + idObject and depending on the
model, won't write back to the source.  All data is saved in a special layer that keeps it separate from other revisions
to the same record.
- When a new idController/idObject version record is created, the source should be allowed to repoll and update the 
base data.  If the base data differs from most recent base data, rebase it.  Base ID should be stored in the Foreign 
model.
- Data that is not different against the current base is left NULL and Foreign keydict columns should be mostly 
non-fixed length fields to allow for the best compression.

// define a ForeignModel the same way local ones are defined
// the PrimaryKey col becomes the main means of identification
$foreign =  Table::build(
                IdInteger::build('apn', 'APN'),
                String::build('address', 'Address'),
            );

// the local keydicts in projects should identify with a $foreign keydict in someway
// it would be nice if this was handled through admin panels, but also a straight tie in would be okay too
Table::build(
            IdInteger::build('idProject', 'Project ID'),
            // require the Address field, but also tell it how to validate against and bind the $foreign keydict
            Address::build('address', 'Address', '')
                ->setRequired()
                ->setForeignKey($foreign->address)
        );

Changes like this, especially those that will allow admin panels to be used to administrate the Keydict, will need to go
though some of the new planned Controllers.


*** Idenfify and Variables Controller Binding

Ignore this it's already been superseded.

    $gis->bindAddress($keydict->address); // primary address for the connection
    $gis->applyRules(); // sync gis info to project

set the value of an Entry to a link to the actual data
link() is available on certain Entry and it returns serializable instructions for looking up the data again,
however when the keydict is written back to the database, it should store the real value

    $keydict->liquefactionZone->link(
        $gis
            ->identify($keydict->address)
            ->extract('/results/2/attributes/devserv_SLCODS_Liquifaction_AREA')
    )->sync();

link tables are essentially ephemeral in the workflow, though can be stored in module settings (aka GIS config)
when link() is called on an Entry, link the value.  sync() tells the Entry to update from the link (effectively set()). 
sync call also be called on an entire Keydict.

GIS module should be able to find compatible Address or APN Entry in the Variables Controllers on the parent.  Using 
an admin interface, settings/rules should be setup that allows the data from GIS::identify() to be link() and sync() to
the Variables.  The GIS module will keep the information up to date by binding listeners on the Variables Controllers
and watching for updates to the specific Entry.

Since the parent will have informed GIS and Variables Controllers talking to each other, the Variables Controller should
automatically know to execute Entry::validate() against the GIS module.

Address, APN, and related Entry should support hidden fields to facilitate the identification process.